package com.multiavatar;

import org.junit.BeforeClass;
import org.junit.Test;
import static org.junit.Assert.*;

import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.ArrayList;

/**
 * Cross-platform compatibility test.
 * Verifies that the Java implementation produces identical output
 * to the JavaScript implementation for the same inputs.
 *
 * Test vectors are generated by running: node generate-test-vectors.cjs
 */
public class CrossPlatformCompatibilityTest {

    private static class TestVector {
        int id;
        String input;
        boolean sansEnv;
        Version version;
        String output;
        int length;
        String error;

        static class Version {
            String part;
            char theme;
        }
    }

    private static List<TestVector> testVectors;

    @BeforeClass
    public static void loadTestVectors() throws IOException {
        testVectors = parseTestVectors("test-vectors.json");
        System.out.println("Loaded " + testVectors.size() + " test vectors from JavaScript implementation");
    }

    @Test
    public void testAllVectorsMatch() {
        int passed = 0;
        int failed = 0;
        List<String> failures = new ArrayList<>();

        for (TestVector vector : testVectors) {
            // Skip vectors that had errors in JS
            if (vector.error != null) {
                continue;
            }

            try {
                // Generate avatar using Java implementation
                String javaOutput;
                if (vector.version != null) {
                    Multiavatar.Version version = new Multiavatar.Version(
                        vector.version.part,
                        vector.version.theme
                    );
                    javaOutput = Multiavatar.generate(vector.input, vector.sansEnv, version);
                } else {
                    javaOutput = Multiavatar.generate(vector.input, vector.sansEnv);
                }

                // Strip attribution metadata from Java output for comparison
                // (Java adds metadata for license compliance)
                String javaOutputStripped = javaOutput.replace("<metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\"><dc:creator>Multiavatar</dc:creator><dc:source>https://multiavatar.com</dc:source></metadata>", "");

                // Compare with JavaScript output
                if (javaOutputStripped.equals(vector.output)) {
                    passed++;
                } else {
                    failed++;
                    String versionStr = vector.version != null ?
                        " [" + vector.version.part + vector.version.theme + "]" : "";
                    String failureMsg = String.format(
                        "Case %d FAILED: \"%s\"%s sansEnv=%b\n" +
                        "  Expected length: %d, Got: %d (stripped: %d)\n" +
                        "  Output differs from JavaScript implementation",
                        vector.id,
                        vector.input.length() > 30 ? vector.input.substring(0, 30) + "..." : vector.input,
                        versionStr,
                        vector.sansEnv,
                        vector.output.length(),
                        javaOutput.length(),
                        javaOutputStripped.length()
                    );
                    failures.add(failureMsg);
                    System.err.println(failureMsg);
                }
            } catch (Exception e) {
                failed++;
                String failureMsg = String.format(
                    "Case %d EXCEPTION: \"%s\" - %s",
                    vector.id,
                    vector.input,
                    e.getMessage()
                );
                failures.add(failureMsg);
                System.err.println(failureMsg);
            }
        }

        // Print summary
        System.out.println("\n=== Cross-Platform Compatibility Test Results ===");
        System.out.println("Total vectors tested: " + (passed + failed));
        System.out.println("Passed: " + passed);
        System.out.println("Failed: " + failed);

        if (failed > 0) {
            System.err.println("\n=== Failures ===");
            for (String failure : failures) {
                System.err.println(failure);
            }
        }

        // Assert all tests passed
        assertEquals("Java implementation must match JavaScript output for all test vectors",
                    0, failed);
    }

    /**
     * Simple JSON parser for test vectors (avoiding external dependencies)
     */
    private static List<TestVector> parseTestVectors(String filename) throws IOException {
        String content = new String(Files.readAllBytes(Paths.get(filename)));
        List<TestVector> vectors = new ArrayList<>();

        // Parse JSON array manually (simple approach for our specific format)
        String[] items = content.substring(content.indexOf('[') + 1, content.lastIndexOf(']'))
            .split("\\},\\s*\\{");

        for (String item : items) {
            item = item.trim();
            if (!item.startsWith("{")) item = "{" + item;
            if (!item.endsWith("}")) item = item + "}";

            TestVector vector = new TestVector();

            // Extract fields
            vector.id = extractInt(item, "\"id\"");
            vector.input = extractString(item, "\"input\"");
            vector.sansEnv = extractBoolean(item, "\"sansEnv\"");
            vector.length = extractInt(item, "\"length\"");
            vector.output = extractString(item, "\"output\"");
            vector.error = extractString(item, "\"error\"");

            // Extract version if present
            int versionStart = item.indexOf("\"version\"");
            if (versionStart > 0) {
                int versionObjStart = item.indexOf('{', versionStart);
                int versionObjEnd = item.indexOf('}', versionObjStart);
                if (versionObjStart > 0 && versionObjEnd > 0) {
                    String versionStr = item.substring(versionObjStart, versionObjEnd + 1);
                    if (!versionStr.contains("null")) {
                        TestVector.Version version = new TestVector.Version();
                        version.part = extractString(versionStr, "\"part\"");
                        String themeStr = extractString(versionStr, "\"theme\"");
                        if (themeStr != null && !themeStr.isEmpty()) {
                            version.theme = themeStr.charAt(0);
                        }
                        vector.version = version;
                    }
                }
            }

            vectors.add(vector);
        }

        return vectors;
    }

    private static String extractString(String json, String key) {
        int keyIndex = json.indexOf(key);
        if (keyIndex < 0) return null;

        int colonIndex = json.indexOf(':', keyIndex);
        int quoteStart = json.indexOf('"', colonIndex);
        if (quoteStart < 0) return null;

        int quoteEnd = quoteStart + 1;
        while (quoteEnd < json.length()) {
            if (json.charAt(quoteEnd) == '"' && json.charAt(quoteEnd - 1) != '\\') {
                break;
            }
            quoteEnd++;
        }

        if (quoteEnd >= json.length()) return null;

        String value = json.substring(quoteStart + 1, quoteEnd);
        // Unescape JSON strings
        value = value.replace("\\\"", "\"")
                    .replace("\\\\", "\\")
                    .replace("\\n", "\n")
                    .replace("\\r", "\r")
                    .replace("\\t", "\t");

        return value;
    }

    private static int extractInt(String json, String key) {
        int keyIndex = json.indexOf(key);
        if (keyIndex < 0) return 0;

        int colonIndex = json.indexOf(':', keyIndex);
        int numStart = colonIndex + 1;

        // Skip whitespace
        while (numStart < json.length() && Character.isWhitespace(json.charAt(numStart))) {
            numStart++;
        }

        int numEnd = numStart;
        while (numEnd < json.length() && (Character.isDigit(json.charAt(numEnd)) || json.charAt(numEnd) == '-')) {
            numEnd++;
        }

        if (numEnd > numStart) {
            return Integer.parseInt(json.substring(numStart, numEnd));
        }

        return 0;
    }

    private static boolean extractBoolean(String json, String key) {
        int keyIndex = json.indexOf(key);
        if (keyIndex < 0) return false;

        int colonIndex = json.indexOf(':', keyIndex);
        String afterColon = json.substring(colonIndex + 1).trim();

        return afterColon.startsWith("true");
    }
}
